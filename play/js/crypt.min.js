var CryptoJS = CryptoJS ||
function(b, c) {
	var d = Object.create ||
	function() {
		function a() {}
		return function(b) {
			var f;
			return a.prototype = b, f = new a, a.prototype = null, f
		}
	}(), a = {}, e = a.lib = {}, h = e.Base = function() {
		return {
			extend: function(a) {
				var b = d(this);
				return a && b.mixIn(a), b.hasOwnProperty("init") && this.init !== b.init || (b.init = function() {
					b.$super.init.apply(this, arguments)
				}), b.init.prototype = b, b.$super = this, b
			},
			create: function() {
				var a = this.extend();
				return a.init.apply(a, arguments), a
			},
			init: function() {},
			mixIn: function(a) {
				for (var b in a) a.hasOwnProperty(b) && (this[b] = a[b]);
				a.hasOwnProperty("toString") && (this.toString = a.toString)
			},
			clone: function() {
				return this.init.prototype.extend(this)
			}
		}
	}(), k = e.WordArray = h.extend({
		init: function(a, b) {
			a = this.words = a || [];
			b != c ? this.sigBytes = b : this.sigBytes = 4 * a.length
		},
		toString: function(a) {
			return (a || m).stringify(this)
		},
		concat: function(a) {
			var b = this.words,
				f = a.words,
				g = this.sigBytes;
			a = a.sigBytes;
			if (this.clamp(), g % 4) for (var c = 0; c < a; c++) b[g + c >>> 2] |= (f[c >>> 2] >>> 24 - c % 4 * 8 & 255) << 24 - (g + c) % 4 * 8;
			else for (c = 0; c < a; c += 4) b[g + c >>> 2] = f[c >>> 2];
			return this.sigBytes += a, this
		},
		clamp: function() {
			var a = this.words,
				c = this.sigBytes;
			a[c >>> 2] &= 4294967295 << 32 - c % 4 * 8;
			a.length = b.ceil(c / 4)
		},
		clone: function() {
			var a = h.clone.call(this);
			return a.words = this.words.slice(0), a
		},
		random: function(a) {
			for (var c, f = [], g = function(a) {
					var f = 987654321;
					return function() {
						f = 36969 * (65535 & f) + (f >> 16) & 4294967295;
						a = 18E3 * (65535 & a) + (a >> 16) & 4294967295;
						var g = (f << 16) + a & 4294967295;
						return g /= 4294967296, g += .5, g * (.5 < b.random() ? 1 : -1)
					}
				}, d = 0; d < a; d += 4) {
				var e = g(4294967296 * (c || b.random()));
				c = 987654071 * e();
				f.push(4294967296 * e() | 0)
			}
			return new k.init(f, a)
		}
	}), l = a.enc = {}, m = l.Hex = {
		stringify: function(a) {
			var b = a.words;
			a = a.sigBytes;
			for (var f = [], g = 0; g < a; g++) {
				var c = b[g >>> 2] >>> 24 - g % 4 * 8 & 255;
				f.push((c >>> 4).toString(16));
				f.push((15 & c).toString(16))
			}
			return f.join("")
		},
		parse: function(a) {
			for (var b = a.length, f = [], g = 0; g < b; g += 2) f[g >>> 3] |= parseInt(a.substr(g, 2), 16) << 24 - g % 8 * 4;
			return new k.init(f, b / 2)
		}
	}, n = l.Latin1 = {
		stringify: function(a) {
			var b = a.words;
			a = a.sigBytes;
			for (var f = [], g = 0; g < a; g++) f.push(String.fromCharCode(b[g >>> 2] >>> 24 - g % 4 * 8 & 255));
			return f.join("")
		},
		parse: function(a) {
			for (var b = a.length, f = [], g = 0; g < b; g++) f[g >>> 2] |= (255 & a.charCodeAt(g)) << 24 - g % 4 * 8;
			return new k.init(f, b)
		}
	}, v = l.Utf8 = {
		stringify: function(a) {
			try {
				return decodeURIComponent(escape(n.stringify(a)))
			} catch (z) {
				throw Error("Malformed UTF-8 data");
			}
		},
		parse: function(a) {
			return n.parse(unescape(encodeURIComponent(a)))
		}
	}, y = e.BufferedBlockAlgorithm = h.extend({
		reset: function() {
			this._data = new k.init;
			this._nDataBytes = 0
		},
		_append: function(a) {
			"string" == typeof a && (a = v.parse(a));
			this._data.concat(a);
			this._nDataBytes += a.sigBytes
		},
		_process: function(a) {
			var c = this._data,
				f = c.words,
				g = c.sigBytes,
				d = this.blockSize,
				e = g / (4 * d),
				e = a ? b.ceil(e) : b.max((0 | e) - this._minBufferSize, 0);
			a = e * d;
			g = b.min(4 * a, g);
			if (a) {
				for (var h = 0; h < a; h += d) this._doProcessBlock(f, h);
				h = f.splice(0, a);
				c.sigBytes -= g
			}
			return new k.init(h, g)
		},
		clone: function() {
			var a = h.clone.call(this);
			return a._data = this._data.clone(), a
		},
		_minBufferSize: 0
	}), w = (e.Hasher = y.extend({
		cfg: h.extend(),
		init: function(a) {
			this.cfg = this.cfg.extend(a);
			this.reset()
		},
		reset: function() {
			y.reset.call(this);
			this._doReset()
		},
		update: function(a) {
			return this._append(a), this._process(), this
		},
		finalize: function(a) {
			a && this._append(a);
			return this._doFinalize()
		},
		blockSize: 16,
		_createHelper: function(a) {
			return function(b, f) {
				return (new a.init(f)).finalize(b)
			}
		},
		_createHmacHelper: function(a) {
			return function(b, f) {
				return (new w.HMAC.init(a, f)).finalize(b)
			}
		}
	}), a.algo = {});
	return a
}(Math);
CryptoJS.lib.Cipher = function(b) {
	var c = CryptoJS,
		d = c.lib,
		a = d.Base,
		e = d.WordArray,
		h = d.BufferedBlockAlgorithm,
		k = c.enc,
		l = (k.Utf8, k.Base64),
		m = c.algo.EvpKDF,
		n = d.Cipher = h.extend({
			cfg: a.extend(),
			createEncryptor: function(a, b) {
				return this.create(this._ENC_XFORM_MODE, a, b)
			},
			createDecryptor: function(a, b) {
				return this.create(this._DEC_XFORM_MODE, a, b)
			},
			init: function(a, b, c) {
				this.cfg = this.cfg.extend(c);
				this._xformMode = a;
				this._key = b;
				this.reset()
			},
			reset: function() {
				h.reset.call(this);
				this._doReset()
			},
			process: function(a) {
				return this._append(a), this._process()
			},
			finalize: function(a) {
				a && this._append(a);
				return this._doFinalize()
			},
			keySize: 4,
			ivSize: 4,
			_ENC_XFORM_MODE: 1,
			_DEC_XFORM_MODE: 2,
			_createHelper: function() {
				return function(a) {
					return {
						encrypt: function(b, f, c) {
							return ("string" == typeof f ? z : t).encrypt(a, b, f, c)
						},
						decrypt: function(b, f, c) {
							return ("string" == typeof f ? z : t).decrypt(a, b, f, c)
						}
					}
				}
			}()
		}),
		k = (d.StreamCipher = n.extend({
			_doFinalize: function() {
				return this._process(!0)
			},
			blockSize: 1
		}), c.mode = {}),
		v = d.BlockCipherMode = a.extend({
			createEncryptor: function(a, b) {
				return this.Encryptor.create(a, b)
			},
			createDecryptor: function(a, b) {
				return this.Decryptor.create(a, b)
			},
			init: function(a, b) {
				this._cipher = a;
				this._iv = b
			}
		}),
		k = k.CBC = function() {
			function a(a, c, f) {
				var g = this._iv;
				g ? this._iv = b : g = this._prevBlock;
				for (var d = 0; d < f; d++) a[c + d] ^= g[d]
			}
			var c = v.extend();
			return c.Encryptor = c.extend({
				processBlock: function(b, c) {
					var f = this._cipher,
						g = f.blockSize;
					a.call(this, b, c, g);
					f.encryptBlock(b, c);
					this._prevBlock = b.slice(c, c + g)
				}
			}), c.Decryptor = c.extend({
				processBlock: function(b, c) {
					var f = this._cipher,
						g = f.blockSize,
						d = b.slice(c, c + g);
					f.decryptBlock(b, c);
					a.call(this, b, c, g);
					this._prevBlock = d
				}
			}), c
		}(),
		y = (c.pad = {}).Pkcs7 = {
			pad: function(a, b) {
				b *= 4;
				b -= a.sigBytes % b;
				for (var c = b << 24 | b << 16 | b << 8 | b, f = [], g = 0; g < b; g += 4) f.push(c);
				b = e.create(f, b);
				a.concat(b)
			},
			unpad: function(a) {
				a.sigBytes -= 255 & a.words[a.sigBytes - 1 >>> 2]
			}
		},
		w = (d.BlockCipher = n.extend({
			cfg: n.cfg.extend({
				mode: k,
				padding: y
			}),
			reset: function() {
				n.reset.call(this);
				var a = this.cfg,
					b = a.iv,
					a = a.mode;
				if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor;
				else c = a.createDecryptor, this._minBufferSize = 1;
				this._mode = c.call(a, this, b && b.words)
			},
			_doProcessBlock: function(a, b) {
				this._mode.processBlock(a, b)
			},
			_doFinalize: function() {
				var a = this.cfg.padding;
				if (this._xformMode == this._ENC_XFORM_MODE) {
					a.pad(this._data, this.blockSize);
					var b = this._process(!0)
				} else b = this._process(!0), a.unpad(b);
				return b
			},
			blockSize: 4
		}), d.CipherParams = a.extend({
			init: function(a) {
				this.mixIn(a)
			},
			toString: function(a) {
				return (a || this.formatter).stringify(this)
			}
		})),
		k = (c.format = {}).OpenSSL = {
			stringify: function(a) {
				var b = a.ciphertext;
				a = a.salt;
				return (a ? e.create([1398893684, 1701076831]).concat(a).concat(b) : b).toString(l)
			},
			parse: function(a) {
				a = l.parse(a);
				var b = a.words;
				if (1398893684 == b[0] && 1701076831 == b[1]) {
					var c = e.create(b.slice(2, 4));
					b.splice(0, 4);
					a.sigBytes -= 16
				}
				return w.create({
					ciphertext: a,
					salt: c
				})
			}
		},
		t = d.SerializableCipher = a.extend({
			cfg: a.extend({
				format: k
			}),
			encrypt: function(a, b, c, d) {
				d = this.cfg.extend(d);
				var f = a.createEncryptor(c, d);
				b = f.finalize(b);
				f = f.cfg;
				return w.create({
					ciphertext: b,
					key: c,
					iv: f.iv,
					algorithm: a,
					mode: f.mode,
					padding: f.padding,
					blockSize: a.blockSize,
					formatter: d.format
				})
			},
			decrypt: function(a, b, c, d) {
				d = this.cfg.extend(d);
				b = this._parse(b, d.format);
				return a.createDecryptor(c, d).finalize(b.ciphertext)
			},
			_parse: function(a, b) {
				return "string" == typeof a ? b.parse(a, this) : a
			}
		}),
		c = (c.kdf = {}).OpenSSL = {
			execute: function(a, b, c, d) {
				d || (d = e.random(8));
				a = m.create({
					keySize: b + c
				}).compute(a, d);
				c = e.create(a.words.slice(b), 4 * c);
				return a.sigBytes = 4 * b, w.create({
					key: a,
					iv: c,
					salt: d
				})
			}
		},
		z = d.PasswordBasedCipher = t.extend({
			cfg: t.cfg.extend({
				kdf: c
			}),
			encrypt: function(a, b, c, d) {
				d = this.cfg.extend(d);
				c = d.kdf.execute(c, a.keySize, a.ivSize);
				d.iv = c.iv;
				a = t.encrypt.call(this, a, b, c.key, d);
				return a.mixIn(c), a
			},
			decrypt: function(a, b, c, d) {
				d = this.cfg.extend(d);
				b = this._parse(b, d.format);
				c = d.kdf.execute(c, a.keySize, a.ivSize, b.salt);
				d.iv = c.iv;
				return t.decrypt.call(this, a, b, c.key, d)
			}
		})
}();
(function(b) {
	var c = CryptoJS,
		d = c.lib,
		a = d.WordArray,
		e = d.Hasher,
		d = c.algo,
		h = [],
		k = [];
	!
	function() {
		function a(a) {
			for (var c = b.sqrt(a), d = 2; d <= c; d++) if (!(a % d)) return !1;
			return !0
		}

		function c(a) {
			return 4294967296 * (a - (0 | a)) | 0
		}
		for (var d = 2, e = 0; 64 > e;) a(d) && (8 > e && (h[e] = c(b.pow(d, .5))), k[e] = c(b.pow(d, 1 / 3)), e++), d++
	}();
	var l = [],
		d = d.SHA256 = e.extend({
			_doReset: function() {
				this._hash = new a.init(h.slice(0))
			},
			_doProcessBlock: function(a, b) {
				for (var c = this._hash.words, d = c[0], e = c[1], h = c[2], z = c[3], f = c[4], g = c[5], m = c[6], q = c[7], p = 0; 64 > p; p++) {
					if (16 > p) l[p] = 0 | a[b + p];
					else {
						var n = l[p - 15],
							u = l[p - 2];
						l[p] = ((n << 25 | n >>> 7) ^ (n << 14 | n >>> 18) ^ n >>> 3) + l[p - 7] + ((u << 15 | u >>> 17) ^ (u << 13 | u >>> 19) ^ u >>> 10) + l[p - 16]
					}
					n = q + ((f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25)) + (f & g ^ ~f & m) + k[p] + l[p];
					u = ((d << 30 | d >>> 2) ^ (d << 19 | d >>> 13) ^ (d << 10 | d >>> 22)) + (d & e ^ d & h ^ e & h);
					q = m;
					m = g;
					g = f;
					f = z + n | 0;
					z = h;
					h = e;
					e = d;
					d = n + u | 0
				}
				c[0] = c[0] + d | 0;
				c[1] = c[1] + e | 0;
				c[2] = c[2] + h | 0;
				c[3] = c[3] + z | 0;
				c[4] = c[4] + f | 0;
				c[5] = c[5] + g | 0;
				c[6] = c[6] + m | 0;
				c[7] = c[7] + q | 0
			},
			_doFinalize: function() {
				var a = this._data,
					c = a.words,
					d = 8 * this._nDataBytes,
					e = 8 * a.sigBytes;
				return c[e >>> 5] |= 128 << 24 - e % 32, c[(e + 64 >>> 9 << 4) + 14] = b.floor(d / 4294967296), c[(e + 64 >>> 9 << 4) + 15] = d, a.sigBytes = 4 * c.length, this._process(), this._hash
			},
			clone: function() {
				var a = e.clone.call(this);
				return a._hash = this._hash.clone(), a
			}
		});
	c.SHA256 = e._createHelper(d);
	c.HmacSHA256 = e._createHmacHelper(d)
})(Math);
(function() {
	var b = CryptoJS,
		c = b.lib.BlockCipher,
		d = b.algo,
		a = [],
		e = [],
		h = [],
		k = [],
		l = [],
		m = [],
		n = [],
		v = [],
		y = [],
		w = [];
	!
	function() {
		for (var b = [], c = 0; 256 > c; c++) 128 > c ? b[c] = c << 1 : b[c] = c << 1 ^ 283;
		for (var d = 0, x = 0, c = 0; 256 > c; c++) {
			var q = x ^ x << 1 ^ x << 2 ^ x << 3 ^ x << 4,
				q = q >>> 8 ^ 255 & q ^ 99;
			a[d] = q;
			e[q] = d;
			var p = b[d],
				t = b[p],
				u = b[t],
				r = 257 * b[q] ^ 16843008 * q;
			h[d] = r << 24 | r >>> 8;
			k[d] = r << 16 | r >>> 16;
			l[d] = r << 8 | r >>> 24;
			m[d] = r;
			r = 16843009 * u ^ 65537 * t ^ 257 * p ^ 16843008 * d;
			n[q] = r << 24 | r >>> 8;
			v[q] = r << 16 | r >>> 16;
			y[q] = r << 8 | r >>> 24;
			w[q] = r;
			d ? (d = p ^ b[b[b[u ^ p]]], x ^= b[b[x]]) : d = x = 1
		}
	}();
	var t = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
		d = d.AES = c.extend({
			_doReset: function() {
				if (!this._nRounds || this._keyPriorReset !== this._key) {
					for (var b = this._keyPriorReset = this._key, c = b.words, d = b.sigBytes / 4, b = 4 * ((this._nRounds = d + 6) + 1), e = this._keySchedule = [], h = 0; h < b; h++) if (h < d) e[h] = c[h];
					else {
						var k = e[h - 1];
						h % d ? 6 < d && 4 == h % d && (k = a[k >>> 24] << 24 | a[k >>> 16 & 255] << 16 | a[k >>> 8 & 255] << 8 | a[255 & k]) : (k = k << 8 | k >>> 24, k = a[k >>> 24] << 24 | a[k >>> 16 & 255] << 16 | a[k >>> 8 & 255] << 8 | a[255 & k], k ^= t[h / d | 0] << 24);
						e[h] = e[h - d] ^ k
					}
					c = this._invKeySchedule = [];
					for (d = 0; d < b; d++) h = b - d, k = d % 4 ? e[h] : e[h - 4], 4 > d || 4 >= h ? c[d] = k : c[d] = n[a[k >>> 24]] ^ v[a[k >>> 16 & 255]] ^ y[a[k >>> 8 & 255]] ^ w[a[255 & k]]
				}
			},
			encryptBlock: function(b, c) {
				this._doCryptBlock(b, c, this._keySchedule, h, k, l, m, a)
			},
			decryptBlock: function(a, b) {
				var c = a[b + 1];
				a[b + 1] = a[b + 3];
				a[b + 3] = c;
				this._doCryptBlock(a, b, this._invKeySchedule, n, v, y, w, e);
				c = a[b + 1];
				a[b + 1] = a[b + 3];
				a[b + 3] = c
			},
			_doCryptBlock: function(a, b, c, d, e, h, k, l) {
				for (var f = this._nRounds, g = a[b] ^ c[0], m = a[b + 1] ^ c[1], n = a[b + 2] ^ c[2], p = a[b + 3] ^ c[3], q = 4, t = 1; t < f; t++) var u = d[g >>> 24] ^ e[m >>> 16 & 255] ^ h[n >>> 8 & 255] ^ k[255 & p] ^ c[q++],
					v = d[m >>> 24] ^ e[n >>> 16 & 255] ^ h[p >>> 8 & 255] ^ k[255 & g] ^ c[q++],
					w = d[n >>> 24] ^ e[p >>> 16 & 255] ^ h[g >>> 8 & 255] ^ k[255 & m] ^ c[q++],
					p = d[p >>> 24] ^ e[g >>> 16 & 255] ^ h[m >>> 8 & 255] ^ k[255 & n] ^ c[q++],
					g = u,
					m = v,
					n = w;
				u = (l[g >>> 24] << 24 | l[m >>> 16 & 255] << 16 | l[n >>> 8 & 255] << 8 | l[255 & p]) ^ c[q++];
				v = (l[m >>> 24] << 24 | l[n >>> 16 & 255] << 16 | l[p >>> 8 & 255] << 8 | l[255 & g]) ^ c[q++];
				w = (l[n >>> 24] << 24 | l[p >>> 16 & 255] << 16 | l[g >>> 8 & 255] << 8 | l[255 & m]) ^ c[q++];
				p = (l[p >>> 24] << 24 | l[g >>> 16 & 255] << 16 | l[m >>> 8 & 255] << 8 | l[255 & n]) ^ c[q++];
				a[b] = u;
				a[b + 1] = v;
				a[b + 2] = w;
				a[b + 3] = p
			},
			keySize: 8
		});
	b.AES = c._createHelper(d)
})();
CryptoJS.mode.ECB = function() {
	var b = CryptoJS.lib.BlockCipherMode.extend();
	return b.Encryptor = b.extend({
		processBlock: function(b, d) {
			this._cipher.encryptBlock(b, d)
		}
	}), b.Decryptor = b.extend({
		processBlock: function(b, d) {
			this._cipher.decryptBlock(b, d)
		}
	}), b
}();
CryptoJS.pad.NoPadding = {
	pad: function() {},
	unpad: function() {}
};
bitArray = {
	bitSlice: function(b, c, d) {
		return b = this._shiftRight(b.slice(c / 32), 32 - (31 & c)).slice(1), void 0 === d ? b : this.clamp(b, d - c)
	},
	extract: function(b, c, d) {
		var a, e = Math.floor(-c - d & 31);
		return a = (c + d - 1 ^ c) & -32 ? b[c / 32 | 0] << 32 - e ^ b[c / 32 + 1 | 0] >>> e : b[c / 32 | 0] >>> e, a & (1 << d) - 1
	},
	concat: function(b, c) {
		if (0 === b.length || 0 === c.length) return b.concat(c);
		var d = b[b.length - 1],
			a = this.getPartial(d);
		return 32 === a ? b.concat(c) : this._shiftRight(c, a, 0 | d, b.slice(0, b.length - 1))
	},
	bitLength: function(b) {
		var c, d = b.length;
		return 0 === d ? 0 : (c = b[d - 1], 32 * (d - 1) + this.getPartial(c))
	},
	clamp: function(b, c) {
		if (32 * b.length < c) return b;
		b = b.slice(0, Math.ceil(c / 32));
		var d = b.length;
		return c &= 31, 0 < d && c && (b[d - 1] = this.partial(c, b[d - 1] & 2147483648 >> c - 1, 1)), b
	},
	partial: function(b, c, d) {
		return 32 === b ? c : (d ? 0 | c : c << 32 - b) + 1099511627776 * b
	},
	getPartial: function(b) {
		return Math.round(b / 1099511627776) || 32
	},
	equal: function(b, c) {
		if (this.bitLength(b) !== this.bitLength(c)) return !1;
		var d, a = 0;
		for (d = 0; d < b.length; d++) a |= b[d] ^ c[d];
		return 0 === a
	},
	_shiftRight: function(b, c, d, a) {
		var e, h, k = 0;
		for (void 0 === a && (a = []); 32 <= c; c -= 32) a.push(d), d = 0;
		if (0 === c) return a.concat(b);
		for (e = 0; e < b.length; e++) a.push(d | b[e] >>> c), d = b[e] << 32 - c;
		return k = b.length ? b[b.length - 1] : 0, h = this.getPartial(k), a.push(this.partial(c + h & 31, 32 < c + h ? d : a.pop(), 1)), a
	},
	_xor4: function(b, c) {
		return [b[0] ^ c[0], b[1] ^ c[1], b[2] ^ c[2], b[3] ^ c[3]]
	},
	byteswapM: function(b) {
		var c, d;
		for (c = 0; c < b.length; ++c) d = b[c], b[c] = d >>> 24 | d >>> 8 & 65280 | (d & 65280) << 8 | d << 24;
		return b
	}
};
bytes = {
	fromBits: function(b) {
		var c, d, a = [],
			e = bitArray.bitLength(b);
		for (c = 0; c < e / 8; c++) 0 === (3 & c) && (d = b[c / 4]), a.push(d >>> 24), d <<= 8;
		for (; 0 < a.length && 0 == a[a.length - 1];) a.pop();
		return a
	},
	toBits: function(b) {
		var c, d = [],
			a = 0;
		for (c = 0; c < b.length; c++) a = a << 8 | b[c], 3 === (3 & c) && (d.push(a), a = 0);
		return 3 & c && d.push(bitArray.partial(8 * (3 & c), a)), d
	}
};
(function(b) {
	if ("object" == typeof exports && "undefined" != typeof module) module.exports = b();
	else if ("function" == typeof define && define.amd) define([], b());
	else {
		if ("undefined" == typeof window) throw Error("wrong execution environment");
		window.TinyStream = b()
	}
})(function() {
	function b(a) {
		if (!(this instanceof b)) return new b(a);
		(this.pool = [], "[object Array]" === Object.prototype.toString.call(a)) ? this.pool = c.init(a) : "[object ArrayBuffer]" == Object.prototype.toString.call(a) ? (a = new Int8Array(a), this.pool = c.init([].slice.call(a))) : "string" == typeof a && (this.pool = c.writeUTF(a));
		var d = this;
		this.writen = this.position = 0;
		this.check = function() {
			return d.position >= d.pool.length
		}
	}
	var c = {
		init: function(a) {
			for (var b = 0; b < a.length; b++) if (a[b] *= 1, 0 > a[b] && (a[b] += 256), 255 < a[b]) throw Error("不合法字节流");
			return a
		},
		writeUTF: function(a, b) {
			for (var c = [], d = 0, e = 0; e < a.length; e++) {
				var m = a.charCodeAt(e);
				0 <= m && 127 >= m ? (d += 1, c.push(m)) : 128 <= m && 2047 >= m ? (d += 2, c.push(192 | 31 & m >> 6), c.push(128 | 63 & m)) : 2048 <= m && 65535 >= m && (d += 3, c.push(224 | 15 & m >> 12), c.push(128 | 63 & m >> 6), c.push(128 | 63 & m))
			}
			for (e = 0; e < c.length; e++) 255 < c[e] && (c[e] &= 255);
			return b ? c : 255 >= d ? [0, d].concat(c) : [d >> 8, 255 & d].concat(c)
		},
		readUTF: function(a) {
			if ("[object String]" == Object.prototype.toString.call(a)) return a;
			var b = "";
			a = this.init(a);
			for (var c = 0; c < a.length; c++) {
				var d = a[c].toString(2),
					l = d.match(/^1+?(?=0)/);
				if (l && 8 == d.length) {
					for (var d = l[0].length, l = a[c].toString(2).slice(7 - d), m = 1; m < d; m++) l += a[m + c].toString(2).slice(2);
					b += String.fromCharCode(parseInt(l, 2));
					c += d - 1
				} else b += String.fromCharCode(a[c])
			}
			return b
		},
		convertStream: function(a) {
			return a instanceof b ? a : new b(a)
		},
		toMQttString: function(a) {
			return this.writeUTF(a)
		}
	},
		d = !! window.ArrayBuffer;
	return b.parse = function(a) {
		return c.convertStream(a)
	}, b.prototype = {
		readInt: function() {
			if (this.check()) return -1;
			for (var a = "", b = 0; 4 > b; b++) a += this.pool[this.position++].toString(16);
			return parseInt(a, 16)
		},
		readByte: function() {
			if (this.check()) return -1;
			var a = this.pool[this.position++];
			return 255 < a && (a &= 255), a
		},
		read: function(a) {
			var b;
			if (this.check()) b = -1;
			else if (a) {
				b = 0 | a.length;
				a = a ? a : [];
				for (var c = 0; c < b; c++) a[c] = this.pool[this.position++];
				b = a
			} else b = this.readByte();
			return b
		},
		readBytes: function(a, c, d) {
			if (this.check()) d = -1;
			else if (void 0 != c && null != c || (c = 0), void 0 != d && null != d || (end = 0 | bytesArray.length), a) {
				a = a ? a : new b;
				a.position = c;
				for (c = offset = this.position; c < d + offset; c++) a.write(this.pool[this.position++]);
				d = a
			} else d = void 0;
			return d
		},
		readUTF: function() {
			var a = this.readByte() << 8 | this.readByte();
			return c.readUTF(this.pool.slice(this.position, this.position += a))
		},
		write: function(a) {
			return "[object array]" == Object.prototype.toString.call(a).toLowerCase() ? ([].push.apply(this.pool, a), this.writen += a.length) : +a == a && (255 < a && (a &= 255), this.pool.push(a), this.writen++), a
		},
		writeBytes: function(a, b, c) {
			var d = a ? a : [];
			c = 0 | a.length;
			for (a = this.writen = b; a < c; a++) this.pool.length - 1 < a ? this.write(d[a]) : this.pool[this.writen++] = d[a];
			return this
		},
		writeChar: function(a) {
			if (+a != a) throw Error("writeChar:arguments type is error");
			this.write(a >> 8 & 255);
			this.write(255 & a);
			this.writen += 2
		},
		writeUTF: function(a, b) {
			a = c.writeUTF(a, b);
			[].push.apply(this.pool, a);
			this.writen += a.length
		},
		toComplements: function() {
			for (var a = this.pool, b = 0; b < a.length; b++) 128 < a[b] && (a[b] -= 256);
			return a
		},
		getBytesArray: function(a) {
			return a ? this.toComplements() : this.pool
		},
		toArrayBuffer: function() {
			if (d) return new ArrayBuffer(this.getBytesArray());
			throw Error("not support arraybuffer");
		},
		clear: function() {
			this.pool = [];
			this.writen = this.position = 0
		},
		length: function() {
			return this.pool.length
		}
	}, b
});
var SECURE_CHANNEL_RANDOM_HEX_SIZE = 32,
	AES_BLOCK_SIZE = 16,
	Hex = CryptoJS.enc.Hex,
	Bytes = bytes,
	Stream = window.TinyStream,
	WordArray = CryptoJS.lib.WordArray,
	sha256 = CryptoJS.SHA256;
pptvH5Crypto = {
	SC_KEY: "UwlJsRX59+ldn2gWmrUnxxFiVuzGL3V@",
	createVVID: function() {
		var e = function(e) {
				for (var a = "", b = '0123456789abcdef', c = 0; c < e; c++) {
					a += b['charAt'](Math.random() * (b.length - 1) >> 0)
				};
				return a
			},
			a = [];
		a.push(e(8));
		for (var b = 0; b < 3; b++) {
			a.push(e(4))
		};
		var c = (new Date).getTime();
		return a.push((0000000 + c.toString(16)).substr(-8) + e(4)), a.join('-')
	},
	getRandom: function() {
		for (var b = "", c = 0; 16 > c; c++) var d = parseInt(93 * Math.random() + 33),
			b = b + String.fromCharCode(d);
		return b
	},
	getSignature: function(b, c) {
		var d = this.getRandom(),
			a = {};
		b = this.toHexStr(d + b + c);
		b = sha256(Hex.parse(b));
		b = Hex.stringify(b);
		return a.sign = b, a.random = this.toHexStr(d), a
	},
	toHexStr: function(b) {
		for (var c = "", d = 0; d < b.length; d++) c += b.charCodeAt(d).toString(16);
		return c
	},
	BytesToStr: function(b) {
		for (var c, d = b.length, a = [], e = 0; e < d; e++) c = b[e], a.push(String.fromCharCode(c));
		return a.join("")
	},
	secure_key_decrypt: function(b, c, d) {
		var a = new Stream;
		if (c.length / 2 < SECURE_CHANNEL_RANDOM_HEX_SIZE + AES_BLOCK_SIZE + 1) return this.BytesToStr(a.pool);
		var e = Hex.parse(d);
		d = new Stream(Bytes.fromBits(e.words));
		var h = new Stream;
		h.writeUTF(b, !0);
		b = new Stream;
		if (d.position = 0, 16 > e.sigBytes) return this.BytesToStr(a.pool);
		h.position = 0;
		d.readBytes(b, 0, 8);
		h.readBytes(b, b.length(), h.length());
		d.readBytes(b, b.length(), 8);
		var e = WordArray.create(Bytes.toBits(b.pool)),
			h = sha256(e),
			k = new Stream(Bytes.fromBits(h.words));
		k.position = 0;
		var l = new Stream(Bytes.fromBits(Hex.parse(c).words));
		c = l.readByte();
		h = new Stream;
		l.readBytes(h, 0, l.length() - 1 - SECURE_CHANNEL_RANDOM_HEX_SIZE);
		var m = new Stream;
		l.readBytes(m, 0, SECURE_CHANNEL_RANDOM_HEX_SIZE);
		var l = CryptoJS.AES,
			n = CryptoJS.lib.CipherParams,
			k = WordArray.create(Bytes.toBits(k.pool)),
			v = WordArray.create(Bytes.toBits(h.pool)),
			k = l.decrypt(n.create({
				ciphertext: v
			}), k, {
				mode: CryptoJS.mode.ECB,
				padding: CryptoJS.pad.NoPadding
			}),
			k = Bytes.fromBits(k.words);
		h.writeBytes(k, 0, k.length);
		b.clear();
		d.position = 8;
		h.position = 0;
		d.readBytes(b, 0, 8);
		h.readBytes(b, b.length(), h.length() - c);
		d.position = 0;
		d.readBytes(b, b.length(), 8);
		b.position = 0;
		d = (WordArray.create(Bytes.toBits(b.pool)), sha256(e));
		d = new Stream(Bytes.fromBits(d.words));
		return this.eqByteArray(d, m) && (h.position = 0, h.readBytes(a, 0, h.length() - c)), this.BytesToStr(a.pool)
	},
	eqByteArray: function(b, c) {
		if (b.length != c.length) return !1;
		var d = b.position,
			a = c.position,
			e = !0;
		for (b.position = c.position = 0; 4 <= b.length;) if (b.readInt() != c.readInt()) {
			e = !1;
			break
		}
		e && 0 != b.length && (e = b.length, e = 1 == e ? b.readByte() == c.readByte() : 2 == e ? b.readShort() == c.readShort() : 3 != e || b.readShort() == c.readShort() && b.readByte() == c.readByte());
		return b.position = d, c.position = a, e
	}
};
